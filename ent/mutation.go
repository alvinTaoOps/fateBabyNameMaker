// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/babyname/fate/ent/character"
	"github.com/babyname/fate/ent/predicate"
	"github.com/babyname/fate/ent/wugelucky"
	"github.com/babyname/fate/ent/wuxing"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharacter = "Character"
	TypeWuGeLucky = "WuGeLucky"
	TypeWuXing    = "WuXing"
)

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	pin_yin                       *string
	ch                            *string
	radical                       *string
	radical_stroke                *int32
	addradical_stroke             *int32
	stroke                        *int32
	addstroke                     *int32
	is_kang_xi                    *bool
	kang_xi                       *string
	kang_xi_stroke                *int32
	addkang_xi_stroke             *int32
	simple_radical                *string
	simple_radical_stroke         *int32
	addsimple_radical_stroke      *int32
	simple_total_stroke           *int32
	addsimple_total_stroke        *int32
	traditional_radical           *string
	traditional_radical_stroke    *int32
	addtraditional_radical_stroke *int32
	traditional_total_stroke      *int32
	addtraditional_total_stroke   *int32
	name_science                  *bool
	wu_xing                       *string
	lucky                         *string
	regular                       *bool
	traditional_character         *string
	variant_character             *string
	comment                       *string
	science_stroke                *int32
	addscience_stroke             *int32
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Character, error)
	predicates                    []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id string) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Character entities.
func (m *CharacterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPinYin sets the "pin_yin" field.
func (m *CharacterMutation) SetPinYin(s string) {
	m.pin_yin = &s
}

// PinYin returns the value of the "pin_yin" field in the mutation.
func (m *CharacterMutation) PinYin() (r string, exists bool) {
	v := m.pin_yin
	if v == nil {
		return
	}
	return *v, true
}

// OldPinYin returns the old "pin_yin" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldPinYin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinYin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinYin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinYin: %w", err)
	}
	return oldValue.PinYin, nil
}

// ResetPinYin resets all changes to the "pin_yin" field.
func (m *CharacterMutation) ResetPinYin() {
	m.pin_yin = nil
}

// SetCh sets the "ch" field.
func (m *CharacterMutation) SetCh(s string) {
	m.ch = &s
}

// Ch returns the value of the "ch" field in the mutation.
func (m *CharacterMutation) Ch() (r string, exists bool) {
	v := m.ch
	if v == nil {
		return
	}
	return *v, true
}

// OldCh returns the old "ch" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCh: %w", err)
	}
	return oldValue.Ch, nil
}

// ResetCh resets all changes to the "ch" field.
func (m *CharacterMutation) ResetCh() {
	m.ch = nil
}

// SetRadical sets the "radical" field.
func (m *CharacterMutation) SetRadical(s string) {
	m.radical = &s
}

// Radical returns the value of the "radical" field in the mutation.
func (m *CharacterMutation) Radical() (r string, exists bool) {
	v := m.radical
	if v == nil {
		return
	}
	return *v, true
}

// OldRadical returns the old "radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadical: %w", err)
	}
	return oldValue.Radical, nil
}

// ResetRadical resets all changes to the "radical" field.
func (m *CharacterMutation) ResetRadical() {
	m.radical = nil
}

// SetRadicalStroke sets the "radical_stroke" field.
func (m *CharacterMutation) SetRadicalStroke(i int32) {
	m.radical_stroke = &i
	m.addradical_stroke = nil
}

// RadicalStroke returns the value of the "radical_stroke" field in the mutation.
func (m *CharacterMutation) RadicalStroke() (r int32, exists bool) {
	v := m.radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldRadicalStroke returns the old "radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRadicalStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRadicalStroke: %w", err)
	}
	return oldValue.RadicalStroke, nil
}

// AddRadicalStroke adds i to the "radical_stroke" field.
func (m *CharacterMutation) AddRadicalStroke(i int32) {
	if m.addradical_stroke != nil {
		*m.addradical_stroke += i
	} else {
		m.addradical_stroke = &i
	}
}

// AddedRadicalStroke returns the value that was added to the "radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedRadicalStroke() (r int32, exists bool) {
	v := m.addradical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetRadicalStroke resets all changes to the "radical_stroke" field.
func (m *CharacterMutation) ResetRadicalStroke() {
	m.radical_stroke = nil
	m.addradical_stroke = nil
}

// SetStroke sets the "stroke" field.
func (m *CharacterMutation) SetStroke(i int32) {
	m.stroke = &i
	m.addstroke = nil
}

// Stroke returns the value of the "stroke" field in the mutation.
func (m *CharacterMutation) Stroke() (r int32, exists bool) {
	v := m.stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldStroke returns the old "stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStroke: %w", err)
	}
	return oldValue.Stroke, nil
}

// AddStroke adds i to the "stroke" field.
func (m *CharacterMutation) AddStroke(i int32) {
	if m.addstroke != nil {
		*m.addstroke += i
	} else {
		m.addstroke = &i
	}
}

// AddedStroke returns the value that was added to the "stroke" field in this mutation.
func (m *CharacterMutation) AddedStroke() (r int32, exists bool) {
	v := m.addstroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetStroke resets all changes to the "stroke" field.
func (m *CharacterMutation) ResetStroke() {
	m.stroke = nil
	m.addstroke = nil
}

// SetIsKangXi sets the "is_kang_xi" field.
func (m *CharacterMutation) SetIsKangXi(b bool) {
	m.is_kang_xi = &b
}

// IsKangXi returns the value of the "is_kang_xi" field in the mutation.
func (m *CharacterMutation) IsKangXi() (r bool, exists bool) {
	v := m.is_kang_xi
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKangXi returns the old "is_kang_xi" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldIsKangXi(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsKangXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsKangXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKangXi: %w", err)
	}
	return oldValue.IsKangXi, nil
}

// ResetIsKangXi resets all changes to the "is_kang_xi" field.
func (m *CharacterMutation) ResetIsKangXi() {
	m.is_kang_xi = nil
}

// SetKangXi sets the "kang_xi" field.
func (m *CharacterMutation) SetKangXi(s string) {
	m.kang_xi = &s
}

// KangXi returns the value of the "kang_xi" field in the mutation.
func (m *CharacterMutation) KangXi() (r string, exists bool) {
	v := m.kang_xi
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXi returns the old "kang_xi" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldKangXi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXi: %w", err)
	}
	return oldValue.KangXi, nil
}

// ResetKangXi resets all changes to the "kang_xi" field.
func (m *CharacterMutation) ResetKangXi() {
	m.kang_xi = nil
}

// SetKangXiStroke sets the "kang_xi_stroke" field.
func (m *CharacterMutation) SetKangXiStroke(i int32) {
	m.kang_xi_stroke = &i
	m.addkang_xi_stroke = nil
}

// KangXiStroke returns the value of the "kang_xi_stroke" field in the mutation.
func (m *CharacterMutation) KangXiStroke() (r int32, exists bool) {
	v := m.kang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldKangXiStroke returns the old "kang_xi_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldKangXiStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKangXiStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKangXiStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKangXiStroke: %w", err)
	}
	return oldValue.KangXiStroke, nil
}

// AddKangXiStroke adds i to the "kang_xi_stroke" field.
func (m *CharacterMutation) AddKangXiStroke(i int32) {
	if m.addkang_xi_stroke != nil {
		*m.addkang_xi_stroke += i
	} else {
		m.addkang_xi_stroke = &i
	}
}

// AddedKangXiStroke returns the value that was added to the "kang_xi_stroke" field in this mutation.
func (m *CharacterMutation) AddedKangXiStroke() (r int32, exists bool) {
	v := m.addkang_xi_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetKangXiStroke resets all changes to the "kang_xi_stroke" field.
func (m *CharacterMutation) ResetKangXiStroke() {
	m.kang_xi_stroke = nil
	m.addkang_xi_stroke = nil
}

// SetSimpleRadical sets the "simple_radical" field.
func (m *CharacterMutation) SetSimpleRadical(s string) {
	m.simple_radical = &s
}

// SimpleRadical returns the value of the "simple_radical" field in the mutation.
func (m *CharacterMutation) SimpleRadical() (r string, exists bool) {
	v := m.simple_radical
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleRadical returns the old "simple_radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleRadical: %w", err)
	}
	return oldValue.SimpleRadical, nil
}

// ResetSimpleRadical resets all changes to the "simple_radical" field.
func (m *CharacterMutation) ResetSimpleRadical() {
	m.simple_radical = nil
}

// SetSimpleRadicalStroke sets the "simple_radical_stroke" field.
func (m *CharacterMutation) SetSimpleRadicalStroke(i int32) {
	m.simple_radical_stroke = &i
	m.addsimple_radical_stroke = nil
}

// SimpleRadicalStroke returns the value of the "simple_radical_stroke" field in the mutation.
func (m *CharacterMutation) SimpleRadicalStroke() (r int32, exists bool) {
	v := m.simple_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleRadicalStroke returns the old "simple_radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleRadicalStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleRadicalStroke: %w", err)
	}
	return oldValue.SimpleRadicalStroke, nil
}

// AddSimpleRadicalStroke adds i to the "simple_radical_stroke" field.
func (m *CharacterMutation) AddSimpleRadicalStroke(i int32) {
	if m.addsimple_radical_stroke != nil {
		*m.addsimple_radical_stroke += i
	} else {
		m.addsimple_radical_stroke = &i
	}
}

// AddedSimpleRadicalStroke returns the value that was added to the "simple_radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedSimpleRadicalStroke() (r int32, exists bool) {
	v := m.addsimple_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetSimpleRadicalStroke resets all changes to the "simple_radical_stroke" field.
func (m *CharacterMutation) ResetSimpleRadicalStroke() {
	m.simple_radical_stroke = nil
	m.addsimple_radical_stroke = nil
}

// SetSimpleTotalStroke sets the "simple_total_stroke" field.
func (m *CharacterMutation) SetSimpleTotalStroke(i int32) {
	m.simple_total_stroke = &i
	m.addsimple_total_stroke = nil
}

// SimpleTotalStroke returns the value of the "simple_total_stroke" field in the mutation.
func (m *CharacterMutation) SimpleTotalStroke() (r int32, exists bool) {
	v := m.simple_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldSimpleTotalStroke returns the old "simple_total_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSimpleTotalStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimpleTotalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimpleTotalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimpleTotalStroke: %w", err)
	}
	return oldValue.SimpleTotalStroke, nil
}

// AddSimpleTotalStroke adds i to the "simple_total_stroke" field.
func (m *CharacterMutation) AddSimpleTotalStroke(i int32) {
	if m.addsimple_total_stroke != nil {
		*m.addsimple_total_stroke += i
	} else {
		m.addsimple_total_stroke = &i
	}
}

// AddedSimpleTotalStroke returns the value that was added to the "simple_total_stroke" field in this mutation.
func (m *CharacterMutation) AddedSimpleTotalStroke() (r int32, exists bool) {
	v := m.addsimple_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetSimpleTotalStroke resets all changes to the "simple_total_stroke" field.
func (m *CharacterMutation) ResetSimpleTotalStroke() {
	m.simple_total_stroke = nil
	m.addsimple_total_stroke = nil
}

// SetTraditionalRadical sets the "traditional_radical" field.
func (m *CharacterMutation) SetTraditionalRadical(s string) {
	m.traditional_radical = &s
}

// TraditionalRadical returns the value of the "traditional_radical" field in the mutation.
func (m *CharacterMutation) TraditionalRadical() (r string, exists bool) {
	v := m.traditional_radical
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalRadical returns the old "traditional_radical" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalRadical(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalRadical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalRadical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalRadical: %w", err)
	}
	return oldValue.TraditionalRadical, nil
}

// ResetTraditionalRadical resets all changes to the "traditional_radical" field.
func (m *CharacterMutation) ResetTraditionalRadical() {
	m.traditional_radical = nil
}

// SetTraditionalRadicalStroke sets the "traditional_radical_stroke" field.
func (m *CharacterMutation) SetTraditionalRadicalStroke(i int32) {
	m.traditional_radical_stroke = &i
	m.addtraditional_radical_stroke = nil
}

// TraditionalRadicalStroke returns the value of the "traditional_radical_stroke" field in the mutation.
func (m *CharacterMutation) TraditionalRadicalStroke() (r int32, exists bool) {
	v := m.traditional_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalRadicalStroke returns the old "traditional_radical_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalRadicalStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalRadicalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalRadicalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalRadicalStroke: %w", err)
	}
	return oldValue.TraditionalRadicalStroke, nil
}

// AddTraditionalRadicalStroke adds i to the "traditional_radical_stroke" field.
func (m *CharacterMutation) AddTraditionalRadicalStroke(i int32) {
	if m.addtraditional_radical_stroke != nil {
		*m.addtraditional_radical_stroke += i
	} else {
		m.addtraditional_radical_stroke = &i
	}
}

// AddedTraditionalRadicalStroke returns the value that was added to the "traditional_radical_stroke" field in this mutation.
func (m *CharacterMutation) AddedTraditionalRadicalStroke() (r int32, exists bool) {
	v := m.addtraditional_radical_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraditionalRadicalStroke resets all changes to the "traditional_radical_stroke" field.
func (m *CharacterMutation) ResetTraditionalRadicalStroke() {
	m.traditional_radical_stroke = nil
	m.addtraditional_radical_stroke = nil
}

// SetTraditionalTotalStroke sets the "traditional_total_stroke" field.
func (m *CharacterMutation) SetTraditionalTotalStroke(i int32) {
	m.traditional_total_stroke = &i
	m.addtraditional_total_stroke = nil
}

// TraditionalTotalStroke returns the value of the "traditional_total_stroke" field in the mutation.
func (m *CharacterMutation) TraditionalTotalStroke() (r int32, exists bool) {
	v := m.traditional_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalTotalStroke returns the old "traditional_total_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalTotalStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalTotalStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalTotalStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalTotalStroke: %w", err)
	}
	return oldValue.TraditionalTotalStroke, nil
}

// AddTraditionalTotalStroke adds i to the "traditional_total_stroke" field.
func (m *CharacterMutation) AddTraditionalTotalStroke(i int32) {
	if m.addtraditional_total_stroke != nil {
		*m.addtraditional_total_stroke += i
	} else {
		m.addtraditional_total_stroke = &i
	}
}

// AddedTraditionalTotalStroke returns the value that was added to the "traditional_total_stroke" field in this mutation.
func (m *CharacterMutation) AddedTraditionalTotalStroke() (r int32, exists bool) {
	v := m.addtraditional_total_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetTraditionalTotalStroke resets all changes to the "traditional_total_stroke" field.
func (m *CharacterMutation) ResetTraditionalTotalStroke() {
	m.traditional_total_stroke = nil
	m.addtraditional_total_stroke = nil
}

// SetNameScience sets the "name_science" field.
func (m *CharacterMutation) SetNameScience(b bool) {
	m.name_science = &b
}

// NameScience returns the value of the "name_science" field in the mutation.
func (m *CharacterMutation) NameScience() (r bool, exists bool) {
	v := m.name_science
	if v == nil {
		return
	}
	return *v, true
}

// OldNameScience returns the old "name_science" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldNameScience(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameScience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameScience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameScience: %w", err)
	}
	return oldValue.NameScience, nil
}

// ResetNameScience resets all changes to the "name_science" field.
func (m *CharacterMutation) ResetNameScience() {
	m.name_science = nil
}

// SetWuXing sets the "wu_xing" field.
func (m *CharacterMutation) SetWuXing(s string) {
	m.wu_xing = &s
}

// WuXing returns the value of the "wu_xing" field in the mutation.
func (m *CharacterMutation) WuXing() (r string, exists bool) {
	v := m.wu_xing
	if v == nil {
		return
	}
	return *v, true
}

// OldWuXing returns the old "wu_xing" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldWuXing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWuXing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWuXing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWuXing: %w", err)
	}
	return oldValue.WuXing, nil
}

// ResetWuXing resets all changes to the "wu_xing" field.
func (m *CharacterMutation) ResetWuXing() {
	m.wu_xing = nil
}

// SetLucky sets the "lucky" field.
func (m *CharacterMutation) SetLucky(s string) {
	m.lucky = &s
}

// Lucky returns the value of the "lucky" field in the mutation.
func (m *CharacterMutation) Lucky() (r string, exists bool) {
	v := m.lucky
	if v == nil {
		return
	}
	return *v, true
}

// OldLucky returns the old "lucky" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLucky(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLucky is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLucky requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLucky: %w", err)
	}
	return oldValue.Lucky, nil
}

// ResetLucky resets all changes to the "lucky" field.
func (m *CharacterMutation) ResetLucky() {
	m.lucky = nil
}

// SetRegular sets the "regular" field.
func (m *CharacterMutation) SetRegular(b bool) {
	m.regular = &b
}

// Regular returns the value of the "regular" field in the mutation.
func (m *CharacterMutation) Regular() (r bool, exists bool) {
	v := m.regular
	if v == nil {
		return
	}
	return *v, true
}

// OldRegular returns the old "regular" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldRegular(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegular is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegular requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegular: %w", err)
	}
	return oldValue.Regular, nil
}

// ResetRegular resets all changes to the "regular" field.
func (m *CharacterMutation) ResetRegular() {
	m.regular = nil
}

// SetTraditionalCharacter sets the "traditional_character" field.
func (m *CharacterMutation) SetTraditionalCharacter(s string) {
	m.traditional_character = &s
}

// TraditionalCharacter returns the value of the "traditional_character" field in the mutation.
func (m *CharacterMutation) TraditionalCharacter() (r string, exists bool) {
	v := m.traditional_character
	if v == nil {
		return
	}
	return *v, true
}

// OldTraditionalCharacter returns the old "traditional_character" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldTraditionalCharacter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraditionalCharacter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraditionalCharacter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraditionalCharacter: %w", err)
	}
	return oldValue.TraditionalCharacter, nil
}

// ResetTraditionalCharacter resets all changes to the "traditional_character" field.
func (m *CharacterMutation) ResetTraditionalCharacter() {
	m.traditional_character = nil
}

// SetVariantCharacter sets the "variant_character" field.
func (m *CharacterMutation) SetVariantCharacter(s string) {
	m.variant_character = &s
}

// VariantCharacter returns the value of the "variant_character" field in the mutation.
func (m *CharacterMutation) VariantCharacter() (r string, exists bool) {
	v := m.variant_character
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantCharacter returns the old "variant_character" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldVariantCharacter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantCharacter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantCharacter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantCharacter: %w", err)
	}
	return oldValue.VariantCharacter, nil
}

// ResetVariantCharacter resets all changes to the "variant_character" field.
func (m *CharacterMutation) ResetVariantCharacter() {
	m.variant_character = nil
}

// SetComment sets the "comment" field.
func (m *CharacterMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *CharacterMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *CharacterMutation) ResetComment() {
	m.comment = nil
}

// SetScienceStroke sets the "science_stroke" field.
func (m *CharacterMutation) SetScienceStroke(i int32) {
	m.science_stroke = &i
	m.addscience_stroke = nil
}

// ScienceStroke returns the value of the "science_stroke" field in the mutation.
func (m *CharacterMutation) ScienceStroke() (r int32, exists bool) {
	v := m.science_stroke
	if v == nil {
		return
	}
	return *v, true
}

// OldScienceStroke returns the old "science_stroke" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldScienceStroke(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScienceStroke is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScienceStroke requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScienceStroke: %w", err)
	}
	return oldValue.ScienceStroke, nil
}

// AddScienceStroke adds i to the "science_stroke" field.
func (m *CharacterMutation) AddScienceStroke(i int32) {
	if m.addscience_stroke != nil {
		*m.addscience_stroke += i
	} else {
		m.addscience_stroke = &i
	}
}

// AddedScienceStroke returns the value that was added to the "science_stroke" field in this mutation.
func (m *CharacterMutation) AddedScienceStroke() (r int32, exists bool) {
	v := m.addscience_stroke
	if v == nil {
		return
	}
	return *v, true
}

// ResetScienceStroke resets all changes to the "science_stroke" field.
func (m *CharacterMutation) ResetScienceStroke() {
	m.science_stroke = nil
	m.addscience_stroke = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.pin_yin != nil {
		fields = append(fields, character.FieldPinYin)
	}
	if m.ch != nil {
		fields = append(fields, character.FieldCh)
	}
	if m.radical != nil {
		fields = append(fields, character.FieldRadical)
	}
	if m.radical_stroke != nil {
		fields = append(fields, character.FieldRadicalStroke)
	}
	if m.stroke != nil {
		fields = append(fields, character.FieldStroke)
	}
	if m.is_kang_xi != nil {
		fields = append(fields, character.FieldIsKangXi)
	}
	if m.kang_xi != nil {
		fields = append(fields, character.FieldKangXi)
	}
	if m.kang_xi_stroke != nil {
		fields = append(fields, character.FieldKangXiStroke)
	}
	if m.simple_radical != nil {
		fields = append(fields, character.FieldSimpleRadical)
	}
	if m.simple_radical_stroke != nil {
		fields = append(fields, character.FieldSimpleRadicalStroke)
	}
	if m.simple_total_stroke != nil {
		fields = append(fields, character.FieldSimpleTotalStroke)
	}
	if m.traditional_radical != nil {
		fields = append(fields, character.FieldTraditionalRadical)
	}
	if m.traditional_radical_stroke != nil {
		fields = append(fields, character.FieldTraditionalRadicalStroke)
	}
	if m.traditional_total_stroke != nil {
		fields = append(fields, character.FieldTraditionalTotalStroke)
	}
	if m.name_science != nil {
		fields = append(fields, character.FieldNameScience)
	}
	if m.wu_xing != nil {
		fields = append(fields, character.FieldWuXing)
	}
	if m.lucky != nil {
		fields = append(fields, character.FieldLucky)
	}
	if m.regular != nil {
		fields = append(fields, character.FieldRegular)
	}
	if m.traditional_character != nil {
		fields = append(fields, character.FieldTraditionalCharacter)
	}
	if m.variant_character != nil {
		fields = append(fields, character.FieldVariantCharacter)
	}
	if m.comment != nil {
		fields = append(fields, character.FieldComment)
	}
	if m.science_stroke != nil {
		fields = append(fields, character.FieldScienceStroke)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldPinYin:
		return m.PinYin()
	case character.FieldCh:
		return m.Ch()
	case character.FieldRadical:
		return m.Radical()
	case character.FieldRadicalStroke:
		return m.RadicalStroke()
	case character.FieldStroke:
		return m.Stroke()
	case character.FieldIsKangXi:
		return m.IsKangXi()
	case character.FieldKangXi:
		return m.KangXi()
	case character.FieldKangXiStroke:
		return m.KangXiStroke()
	case character.FieldSimpleRadical:
		return m.SimpleRadical()
	case character.FieldSimpleRadicalStroke:
		return m.SimpleRadicalStroke()
	case character.FieldSimpleTotalStroke:
		return m.SimpleTotalStroke()
	case character.FieldTraditionalRadical:
		return m.TraditionalRadical()
	case character.FieldTraditionalRadicalStroke:
		return m.TraditionalRadicalStroke()
	case character.FieldTraditionalTotalStroke:
		return m.TraditionalTotalStroke()
	case character.FieldNameScience:
		return m.NameScience()
	case character.FieldWuXing:
		return m.WuXing()
	case character.FieldLucky:
		return m.Lucky()
	case character.FieldRegular:
		return m.Regular()
	case character.FieldTraditionalCharacter:
		return m.TraditionalCharacter()
	case character.FieldVariantCharacter:
		return m.VariantCharacter()
	case character.FieldComment:
		return m.Comment()
	case character.FieldScienceStroke:
		return m.ScienceStroke()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldPinYin:
		return m.OldPinYin(ctx)
	case character.FieldCh:
		return m.OldCh(ctx)
	case character.FieldRadical:
		return m.OldRadical(ctx)
	case character.FieldRadicalStroke:
		return m.OldRadicalStroke(ctx)
	case character.FieldStroke:
		return m.OldStroke(ctx)
	case character.FieldIsKangXi:
		return m.OldIsKangXi(ctx)
	case character.FieldKangXi:
		return m.OldKangXi(ctx)
	case character.FieldKangXiStroke:
		return m.OldKangXiStroke(ctx)
	case character.FieldSimpleRadical:
		return m.OldSimpleRadical(ctx)
	case character.FieldSimpleRadicalStroke:
		return m.OldSimpleRadicalStroke(ctx)
	case character.FieldSimpleTotalStroke:
		return m.OldSimpleTotalStroke(ctx)
	case character.FieldTraditionalRadical:
		return m.OldTraditionalRadical(ctx)
	case character.FieldTraditionalRadicalStroke:
		return m.OldTraditionalRadicalStroke(ctx)
	case character.FieldTraditionalTotalStroke:
		return m.OldTraditionalTotalStroke(ctx)
	case character.FieldNameScience:
		return m.OldNameScience(ctx)
	case character.FieldWuXing:
		return m.OldWuXing(ctx)
	case character.FieldLucky:
		return m.OldLucky(ctx)
	case character.FieldRegular:
		return m.OldRegular(ctx)
	case character.FieldTraditionalCharacter:
		return m.OldTraditionalCharacter(ctx)
	case character.FieldVariantCharacter:
		return m.OldVariantCharacter(ctx)
	case character.FieldComment:
		return m.OldComment(ctx)
	case character.FieldScienceStroke:
		return m.OldScienceStroke(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldPinYin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinYin(v)
		return nil
	case character.FieldCh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCh(v)
		return nil
	case character.FieldRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadical(v)
		return nil
	case character.FieldRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRadicalStroke(v)
		return nil
	case character.FieldStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStroke(v)
		return nil
	case character.FieldIsKangXi:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKangXi(v)
		return nil
	case character.FieldKangXi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXi(v)
		return nil
	case character.FieldKangXiStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKangXiStroke(v)
		return nil
	case character.FieldSimpleRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleRadical(v)
		return nil
	case character.FieldSimpleRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleRadicalStroke(v)
		return nil
	case character.FieldSimpleTotalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimpleTotalStroke(v)
		return nil
	case character.FieldTraditionalRadical:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalRadical(v)
		return nil
	case character.FieldTraditionalRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalRadicalStroke(v)
		return nil
	case character.FieldTraditionalTotalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalTotalStroke(v)
		return nil
	case character.FieldNameScience:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameScience(v)
		return nil
	case character.FieldWuXing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWuXing(v)
		return nil
	case character.FieldLucky:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLucky(v)
		return nil
	case character.FieldRegular:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegular(v)
		return nil
	case character.FieldTraditionalCharacter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraditionalCharacter(v)
		return nil
	case character.FieldVariantCharacter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantCharacter(v)
		return nil
	case character.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case character.FieldScienceStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScienceStroke(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	var fields []string
	if m.addradical_stroke != nil {
		fields = append(fields, character.FieldRadicalStroke)
	}
	if m.addstroke != nil {
		fields = append(fields, character.FieldStroke)
	}
	if m.addkang_xi_stroke != nil {
		fields = append(fields, character.FieldKangXiStroke)
	}
	if m.addsimple_radical_stroke != nil {
		fields = append(fields, character.FieldSimpleRadicalStroke)
	}
	if m.addsimple_total_stroke != nil {
		fields = append(fields, character.FieldSimpleTotalStroke)
	}
	if m.addtraditional_radical_stroke != nil {
		fields = append(fields, character.FieldTraditionalRadicalStroke)
	}
	if m.addtraditional_total_stroke != nil {
		fields = append(fields, character.FieldTraditionalTotalStroke)
	}
	if m.addscience_stroke != nil {
		fields = append(fields, character.FieldScienceStroke)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case character.FieldRadicalStroke:
		return m.AddedRadicalStroke()
	case character.FieldStroke:
		return m.AddedStroke()
	case character.FieldKangXiStroke:
		return m.AddedKangXiStroke()
	case character.FieldSimpleRadicalStroke:
		return m.AddedSimpleRadicalStroke()
	case character.FieldSimpleTotalStroke:
		return m.AddedSimpleTotalStroke()
	case character.FieldTraditionalRadicalStroke:
		return m.AddedTraditionalRadicalStroke()
	case character.FieldTraditionalTotalStroke:
		return m.AddedTraditionalTotalStroke()
	case character.FieldScienceStroke:
		return m.AddedScienceStroke()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case character.FieldRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRadicalStroke(v)
		return nil
	case character.FieldStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStroke(v)
		return nil
	case character.FieldKangXiStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKangXiStroke(v)
		return nil
	case character.FieldSimpleRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimpleRadicalStroke(v)
		return nil
	case character.FieldSimpleTotalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimpleTotalStroke(v)
		return nil
	case character.FieldTraditionalRadicalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraditionalRadicalStroke(v)
		return nil
	case character.FieldTraditionalTotalStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTraditionalTotalStroke(v)
		return nil
	case character.FieldScienceStroke:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScienceStroke(v)
		return nil
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldPinYin:
		m.ResetPinYin()
		return nil
	case character.FieldCh:
		m.ResetCh()
		return nil
	case character.FieldRadical:
		m.ResetRadical()
		return nil
	case character.FieldRadicalStroke:
		m.ResetRadicalStroke()
		return nil
	case character.FieldStroke:
		m.ResetStroke()
		return nil
	case character.FieldIsKangXi:
		m.ResetIsKangXi()
		return nil
	case character.FieldKangXi:
		m.ResetKangXi()
		return nil
	case character.FieldKangXiStroke:
		m.ResetKangXiStroke()
		return nil
	case character.FieldSimpleRadical:
		m.ResetSimpleRadical()
		return nil
	case character.FieldSimpleRadicalStroke:
		m.ResetSimpleRadicalStroke()
		return nil
	case character.FieldSimpleTotalStroke:
		m.ResetSimpleTotalStroke()
		return nil
	case character.FieldTraditionalRadical:
		m.ResetTraditionalRadical()
		return nil
	case character.FieldTraditionalRadicalStroke:
		m.ResetTraditionalRadicalStroke()
		return nil
	case character.FieldTraditionalTotalStroke:
		m.ResetTraditionalTotalStroke()
		return nil
	case character.FieldNameScience:
		m.ResetNameScience()
		return nil
	case character.FieldWuXing:
		m.ResetWuXing()
		return nil
	case character.FieldLucky:
		m.ResetLucky()
		return nil
	case character.FieldRegular:
		m.ResetRegular()
		return nil
	case character.FieldTraditionalCharacter:
		m.ResetTraditionalCharacter()
		return nil
	case character.FieldVariantCharacter:
		m.ResetVariantCharacter()
		return nil
	case character.FieldComment:
		m.ResetComment()
		return nil
	case character.FieldScienceStroke:
		m.ResetScienceStroke()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Character edge %s", name)
}

// WuGeLuckyMutation represents an operation that mutates the WuGeLucky nodes in the graph.
type WuGeLuckyMutation struct {
	config
	op                Op
	typ               string
	id                *string
	last_stroke_1     *int32
	addlast_stroke_1  *int32
	last_stroke_2     *int32
	addlast_stroke_2  *int32
	first_stroke_1    *int32
	addfirst_stroke_1 *int32
	first_stroke_2    *int32
	addfirst_stroke_2 *int32
	tian_ge           *int32
	addtian_ge        *int32
	tian_da_yan       *string
	ren_ge            *int32
	addren_ge         *int32
	ren_da_yan        *string
	di_ge             *int32
	adddi_ge          *int32
	di_da_yan         *string
	wai_ge            *int32
	addwai_ge         *int32
	wai_da_yan        *string
	zong_ge           *int32
	addzong_ge        *int32
	zong_da_yan       *string
	zong_lucky        *bool
	zong_sex          *bool
	zong_max          *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*WuGeLucky, error)
	predicates        []predicate.WuGeLucky
}

var _ ent.Mutation = (*WuGeLuckyMutation)(nil)

// wugeluckyOption allows management of the mutation configuration using functional options.
type wugeluckyOption func(*WuGeLuckyMutation)

// newWuGeLuckyMutation creates new mutation for the WuGeLucky entity.
func newWuGeLuckyMutation(c config, op Op, opts ...wugeluckyOption) *WuGeLuckyMutation {
	m := &WuGeLuckyMutation{
		config:        c,
		op:            op,
		typ:           TypeWuGeLucky,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWuGeLuckyID sets the ID field of the mutation.
func withWuGeLuckyID(id string) wugeluckyOption {
	return func(m *WuGeLuckyMutation) {
		var (
			err   error
			once  sync.Once
			value *WuGeLucky
		)
		m.oldValue = func(ctx context.Context) (*WuGeLucky, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WuGeLucky.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWuGeLucky sets the old WuGeLucky of the mutation.
func withWuGeLucky(node *WuGeLucky) wugeluckyOption {
	return func(m *WuGeLuckyMutation) {
		m.oldValue = func(context.Context) (*WuGeLucky, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WuGeLuckyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WuGeLuckyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WuGeLucky entities.
func (m *WuGeLuckyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WuGeLuckyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WuGeLuckyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WuGeLucky.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastStroke1 sets the "last_stroke_1" field.
func (m *WuGeLuckyMutation) SetLastStroke1(i int32) {
	m.last_stroke_1 = &i
	m.addlast_stroke_1 = nil
}

// LastStroke1 returns the value of the "last_stroke_1" field in the mutation.
func (m *WuGeLuckyMutation) LastStroke1() (r int32, exists bool) {
	v := m.last_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStroke1 returns the old "last_stroke_1" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldLastStroke1(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStroke1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStroke1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStroke1: %w", err)
	}
	return oldValue.LastStroke1, nil
}

// AddLastStroke1 adds i to the "last_stroke_1" field.
func (m *WuGeLuckyMutation) AddLastStroke1(i int32) {
	if m.addlast_stroke_1 != nil {
		*m.addlast_stroke_1 += i
	} else {
		m.addlast_stroke_1 = &i
	}
}

// AddedLastStroke1 returns the value that was added to the "last_stroke_1" field in this mutation.
func (m *WuGeLuckyMutation) AddedLastStroke1() (r int32, exists bool) {
	v := m.addlast_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastStroke1 clears the value of the "last_stroke_1" field.
func (m *WuGeLuckyMutation) ClearLastStroke1() {
	m.last_stroke_1 = nil
	m.addlast_stroke_1 = nil
	m.clearedFields[wugelucky.FieldLastStroke1] = struct{}{}
}

// LastStroke1Cleared returns if the "last_stroke_1" field was cleared in this mutation.
func (m *WuGeLuckyMutation) LastStroke1Cleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldLastStroke1]
	return ok
}

// ResetLastStroke1 resets all changes to the "last_stroke_1" field.
func (m *WuGeLuckyMutation) ResetLastStroke1() {
	m.last_stroke_1 = nil
	m.addlast_stroke_1 = nil
	delete(m.clearedFields, wugelucky.FieldLastStroke1)
}

// SetLastStroke2 sets the "last_stroke_2" field.
func (m *WuGeLuckyMutation) SetLastStroke2(i int32) {
	m.last_stroke_2 = &i
	m.addlast_stroke_2 = nil
}

// LastStroke2 returns the value of the "last_stroke_2" field in the mutation.
func (m *WuGeLuckyMutation) LastStroke2() (r int32, exists bool) {
	v := m.last_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStroke2 returns the old "last_stroke_2" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldLastStroke2(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStroke2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStroke2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStroke2: %w", err)
	}
	return oldValue.LastStroke2, nil
}

// AddLastStroke2 adds i to the "last_stroke_2" field.
func (m *WuGeLuckyMutation) AddLastStroke2(i int32) {
	if m.addlast_stroke_2 != nil {
		*m.addlast_stroke_2 += i
	} else {
		m.addlast_stroke_2 = &i
	}
}

// AddedLastStroke2 returns the value that was added to the "last_stroke_2" field in this mutation.
func (m *WuGeLuckyMutation) AddedLastStroke2() (r int32, exists bool) {
	v := m.addlast_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastStroke2 clears the value of the "last_stroke_2" field.
func (m *WuGeLuckyMutation) ClearLastStroke2() {
	m.last_stroke_2 = nil
	m.addlast_stroke_2 = nil
	m.clearedFields[wugelucky.FieldLastStroke2] = struct{}{}
}

// LastStroke2Cleared returns if the "last_stroke_2" field was cleared in this mutation.
func (m *WuGeLuckyMutation) LastStroke2Cleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldLastStroke2]
	return ok
}

// ResetLastStroke2 resets all changes to the "last_stroke_2" field.
func (m *WuGeLuckyMutation) ResetLastStroke2() {
	m.last_stroke_2 = nil
	m.addlast_stroke_2 = nil
	delete(m.clearedFields, wugelucky.FieldLastStroke2)
}

// SetFirstStroke1 sets the "first_stroke_1" field.
func (m *WuGeLuckyMutation) SetFirstStroke1(i int32) {
	m.first_stroke_1 = &i
	m.addfirst_stroke_1 = nil
}

// FirstStroke1 returns the value of the "first_stroke_1" field in the mutation.
func (m *WuGeLuckyMutation) FirstStroke1() (r int32, exists bool) {
	v := m.first_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStroke1 returns the old "first_stroke_1" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldFirstStroke1(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStroke1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStroke1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStroke1: %w", err)
	}
	return oldValue.FirstStroke1, nil
}

// AddFirstStroke1 adds i to the "first_stroke_1" field.
func (m *WuGeLuckyMutation) AddFirstStroke1(i int32) {
	if m.addfirst_stroke_1 != nil {
		*m.addfirst_stroke_1 += i
	} else {
		m.addfirst_stroke_1 = &i
	}
}

// AddedFirstStroke1 returns the value that was added to the "first_stroke_1" field in this mutation.
func (m *WuGeLuckyMutation) AddedFirstStroke1() (r int32, exists bool) {
	v := m.addfirst_stroke_1
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstStroke1 clears the value of the "first_stroke_1" field.
func (m *WuGeLuckyMutation) ClearFirstStroke1() {
	m.first_stroke_1 = nil
	m.addfirst_stroke_1 = nil
	m.clearedFields[wugelucky.FieldFirstStroke1] = struct{}{}
}

// FirstStroke1Cleared returns if the "first_stroke_1" field was cleared in this mutation.
func (m *WuGeLuckyMutation) FirstStroke1Cleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldFirstStroke1]
	return ok
}

// ResetFirstStroke1 resets all changes to the "first_stroke_1" field.
func (m *WuGeLuckyMutation) ResetFirstStroke1() {
	m.first_stroke_1 = nil
	m.addfirst_stroke_1 = nil
	delete(m.clearedFields, wugelucky.FieldFirstStroke1)
}

// SetFirstStroke2 sets the "first_stroke_2" field.
func (m *WuGeLuckyMutation) SetFirstStroke2(i int32) {
	m.first_stroke_2 = &i
	m.addfirst_stroke_2 = nil
}

// FirstStroke2 returns the value of the "first_stroke_2" field in the mutation.
func (m *WuGeLuckyMutation) FirstStroke2() (r int32, exists bool) {
	v := m.first_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstStroke2 returns the old "first_stroke_2" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldFirstStroke2(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstStroke2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstStroke2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstStroke2: %w", err)
	}
	return oldValue.FirstStroke2, nil
}

// AddFirstStroke2 adds i to the "first_stroke_2" field.
func (m *WuGeLuckyMutation) AddFirstStroke2(i int32) {
	if m.addfirst_stroke_2 != nil {
		*m.addfirst_stroke_2 += i
	} else {
		m.addfirst_stroke_2 = &i
	}
}

// AddedFirstStroke2 returns the value that was added to the "first_stroke_2" field in this mutation.
func (m *WuGeLuckyMutation) AddedFirstStroke2() (r int32, exists bool) {
	v := m.addfirst_stroke_2
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstStroke2 clears the value of the "first_stroke_2" field.
func (m *WuGeLuckyMutation) ClearFirstStroke2() {
	m.first_stroke_2 = nil
	m.addfirst_stroke_2 = nil
	m.clearedFields[wugelucky.FieldFirstStroke2] = struct{}{}
}

// FirstStroke2Cleared returns if the "first_stroke_2" field was cleared in this mutation.
func (m *WuGeLuckyMutation) FirstStroke2Cleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldFirstStroke2]
	return ok
}

// ResetFirstStroke2 resets all changes to the "first_stroke_2" field.
func (m *WuGeLuckyMutation) ResetFirstStroke2() {
	m.first_stroke_2 = nil
	m.addfirst_stroke_2 = nil
	delete(m.clearedFields, wugelucky.FieldFirstStroke2)
}

// SetTianGe sets the "tian_ge" field.
func (m *WuGeLuckyMutation) SetTianGe(i int32) {
	m.tian_ge = &i
	m.addtian_ge = nil
}

// TianGe returns the value of the "tian_ge" field in the mutation.
func (m *WuGeLuckyMutation) TianGe() (r int32, exists bool) {
	v := m.tian_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldTianGe returns the old "tian_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldTianGe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTianGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTianGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTianGe: %w", err)
	}
	return oldValue.TianGe, nil
}

// AddTianGe adds i to the "tian_ge" field.
func (m *WuGeLuckyMutation) AddTianGe(i int32) {
	if m.addtian_ge != nil {
		*m.addtian_ge += i
	} else {
		m.addtian_ge = &i
	}
}

// AddedTianGe returns the value that was added to the "tian_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedTianGe() (r int32, exists bool) {
	v := m.addtian_ge
	if v == nil {
		return
	}
	return *v, true
}

// ClearTianGe clears the value of the "tian_ge" field.
func (m *WuGeLuckyMutation) ClearTianGe() {
	m.tian_ge = nil
	m.addtian_ge = nil
	m.clearedFields[wugelucky.FieldTianGe] = struct{}{}
}

// TianGeCleared returns if the "tian_ge" field was cleared in this mutation.
func (m *WuGeLuckyMutation) TianGeCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldTianGe]
	return ok
}

// ResetTianGe resets all changes to the "tian_ge" field.
func (m *WuGeLuckyMutation) ResetTianGe() {
	m.tian_ge = nil
	m.addtian_ge = nil
	delete(m.clearedFields, wugelucky.FieldTianGe)
}

// SetTianDaYan sets the "tian_da_yan" field.
func (m *WuGeLuckyMutation) SetTianDaYan(s string) {
	m.tian_da_yan = &s
}

// TianDaYan returns the value of the "tian_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) TianDaYan() (r string, exists bool) {
	v := m.tian_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldTianDaYan returns the old "tian_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldTianDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTianDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTianDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTianDaYan: %w", err)
	}
	return oldValue.TianDaYan, nil
}

// ClearTianDaYan clears the value of the "tian_da_yan" field.
func (m *WuGeLuckyMutation) ClearTianDaYan() {
	m.tian_da_yan = nil
	m.clearedFields[wugelucky.FieldTianDaYan] = struct{}{}
}

// TianDaYanCleared returns if the "tian_da_yan" field was cleared in this mutation.
func (m *WuGeLuckyMutation) TianDaYanCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldTianDaYan]
	return ok
}

// ResetTianDaYan resets all changes to the "tian_da_yan" field.
func (m *WuGeLuckyMutation) ResetTianDaYan() {
	m.tian_da_yan = nil
	delete(m.clearedFields, wugelucky.FieldTianDaYan)
}

// SetRenGe sets the "ren_ge" field.
func (m *WuGeLuckyMutation) SetRenGe(i int32) {
	m.ren_ge = &i
	m.addren_ge = nil
}

// RenGe returns the value of the "ren_ge" field in the mutation.
func (m *WuGeLuckyMutation) RenGe() (r int32, exists bool) {
	v := m.ren_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldRenGe returns the old "ren_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldRenGe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenGe: %w", err)
	}
	return oldValue.RenGe, nil
}

// AddRenGe adds i to the "ren_ge" field.
func (m *WuGeLuckyMutation) AddRenGe(i int32) {
	if m.addren_ge != nil {
		*m.addren_ge += i
	} else {
		m.addren_ge = &i
	}
}

// AddedRenGe returns the value that was added to the "ren_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedRenGe() (r int32, exists bool) {
	v := m.addren_ge
	if v == nil {
		return
	}
	return *v, true
}

// ClearRenGe clears the value of the "ren_ge" field.
func (m *WuGeLuckyMutation) ClearRenGe() {
	m.ren_ge = nil
	m.addren_ge = nil
	m.clearedFields[wugelucky.FieldRenGe] = struct{}{}
}

// RenGeCleared returns if the "ren_ge" field was cleared in this mutation.
func (m *WuGeLuckyMutation) RenGeCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldRenGe]
	return ok
}

// ResetRenGe resets all changes to the "ren_ge" field.
func (m *WuGeLuckyMutation) ResetRenGe() {
	m.ren_ge = nil
	m.addren_ge = nil
	delete(m.clearedFields, wugelucky.FieldRenGe)
}

// SetRenDaYan sets the "ren_da_yan" field.
func (m *WuGeLuckyMutation) SetRenDaYan(s string) {
	m.ren_da_yan = &s
}

// RenDaYan returns the value of the "ren_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) RenDaYan() (r string, exists bool) {
	v := m.ren_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldRenDaYan returns the old "ren_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldRenDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenDaYan: %w", err)
	}
	return oldValue.RenDaYan, nil
}

// ClearRenDaYan clears the value of the "ren_da_yan" field.
func (m *WuGeLuckyMutation) ClearRenDaYan() {
	m.ren_da_yan = nil
	m.clearedFields[wugelucky.FieldRenDaYan] = struct{}{}
}

// RenDaYanCleared returns if the "ren_da_yan" field was cleared in this mutation.
func (m *WuGeLuckyMutation) RenDaYanCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldRenDaYan]
	return ok
}

// ResetRenDaYan resets all changes to the "ren_da_yan" field.
func (m *WuGeLuckyMutation) ResetRenDaYan() {
	m.ren_da_yan = nil
	delete(m.clearedFields, wugelucky.FieldRenDaYan)
}

// SetDiGe sets the "di_ge" field.
func (m *WuGeLuckyMutation) SetDiGe(i int32) {
	m.di_ge = &i
	m.adddi_ge = nil
}

// DiGe returns the value of the "di_ge" field in the mutation.
func (m *WuGeLuckyMutation) DiGe() (r int32, exists bool) {
	v := m.di_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldDiGe returns the old "di_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldDiGe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiGe: %w", err)
	}
	return oldValue.DiGe, nil
}

// AddDiGe adds i to the "di_ge" field.
func (m *WuGeLuckyMutation) AddDiGe(i int32) {
	if m.adddi_ge != nil {
		*m.adddi_ge += i
	} else {
		m.adddi_ge = &i
	}
}

// AddedDiGe returns the value that was added to the "di_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedDiGe() (r int32, exists bool) {
	v := m.adddi_ge
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiGe clears the value of the "di_ge" field.
func (m *WuGeLuckyMutation) ClearDiGe() {
	m.di_ge = nil
	m.adddi_ge = nil
	m.clearedFields[wugelucky.FieldDiGe] = struct{}{}
}

// DiGeCleared returns if the "di_ge" field was cleared in this mutation.
func (m *WuGeLuckyMutation) DiGeCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldDiGe]
	return ok
}

// ResetDiGe resets all changes to the "di_ge" field.
func (m *WuGeLuckyMutation) ResetDiGe() {
	m.di_ge = nil
	m.adddi_ge = nil
	delete(m.clearedFields, wugelucky.FieldDiGe)
}

// SetDiDaYan sets the "di_da_yan" field.
func (m *WuGeLuckyMutation) SetDiDaYan(s string) {
	m.di_da_yan = &s
}

// DiDaYan returns the value of the "di_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) DiDaYan() (r string, exists bool) {
	v := m.di_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldDiDaYan returns the old "di_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldDiDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiDaYan: %w", err)
	}
	return oldValue.DiDaYan, nil
}

// ClearDiDaYan clears the value of the "di_da_yan" field.
func (m *WuGeLuckyMutation) ClearDiDaYan() {
	m.di_da_yan = nil
	m.clearedFields[wugelucky.FieldDiDaYan] = struct{}{}
}

// DiDaYanCleared returns if the "di_da_yan" field was cleared in this mutation.
func (m *WuGeLuckyMutation) DiDaYanCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldDiDaYan]
	return ok
}

// ResetDiDaYan resets all changes to the "di_da_yan" field.
func (m *WuGeLuckyMutation) ResetDiDaYan() {
	m.di_da_yan = nil
	delete(m.clearedFields, wugelucky.FieldDiDaYan)
}

// SetWaiGe sets the "wai_ge" field.
func (m *WuGeLuckyMutation) SetWaiGe(i int32) {
	m.wai_ge = &i
	m.addwai_ge = nil
}

// WaiGe returns the value of the "wai_ge" field in the mutation.
func (m *WuGeLuckyMutation) WaiGe() (r int32, exists bool) {
	v := m.wai_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiGe returns the old "wai_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldWaiGe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiGe: %w", err)
	}
	return oldValue.WaiGe, nil
}

// AddWaiGe adds i to the "wai_ge" field.
func (m *WuGeLuckyMutation) AddWaiGe(i int32) {
	if m.addwai_ge != nil {
		*m.addwai_ge += i
	} else {
		m.addwai_ge = &i
	}
}

// AddedWaiGe returns the value that was added to the "wai_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedWaiGe() (r int32, exists bool) {
	v := m.addwai_ge
	if v == nil {
		return
	}
	return *v, true
}

// ClearWaiGe clears the value of the "wai_ge" field.
func (m *WuGeLuckyMutation) ClearWaiGe() {
	m.wai_ge = nil
	m.addwai_ge = nil
	m.clearedFields[wugelucky.FieldWaiGe] = struct{}{}
}

// WaiGeCleared returns if the "wai_ge" field was cleared in this mutation.
func (m *WuGeLuckyMutation) WaiGeCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldWaiGe]
	return ok
}

// ResetWaiGe resets all changes to the "wai_ge" field.
func (m *WuGeLuckyMutation) ResetWaiGe() {
	m.wai_ge = nil
	m.addwai_ge = nil
	delete(m.clearedFields, wugelucky.FieldWaiGe)
}

// SetWaiDaYan sets the "wai_da_yan" field.
func (m *WuGeLuckyMutation) SetWaiDaYan(s string) {
	m.wai_da_yan = &s
}

// WaiDaYan returns the value of the "wai_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) WaiDaYan() (r string, exists bool) {
	v := m.wai_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiDaYan returns the old "wai_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldWaiDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiDaYan: %w", err)
	}
	return oldValue.WaiDaYan, nil
}

// ClearWaiDaYan clears the value of the "wai_da_yan" field.
func (m *WuGeLuckyMutation) ClearWaiDaYan() {
	m.wai_da_yan = nil
	m.clearedFields[wugelucky.FieldWaiDaYan] = struct{}{}
}

// WaiDaYanCleared returns if the "wai_da_yan" field was cleared in this mutation.
func (m *WuGeLuckyMutation) WaiDaYanCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldWaiDaYan]
	return ok
}

// ResetWaiDaYan resets all changes to the "wai_da_yan" field.
func (m *WuGeLuckyMutation) ResetWaiDaYan() {
	m.wai_da_yan = nil
	delete(m.clearedFields, wugelucky.FieldWaiDaYan)
}

// SetZongGe sets the "zong_ge" field.
func (m *WuGeLuckyMutation) SetZongGe(i int32) {
	m.zong_ge = &i
	m.addzong_ge = nil
}

// ZongGe returns the value of the "zong_ge" field in the mutation.
func (m *WuGeLuckyMutation) ZongGe() (r int32, exists bool) {
	v := m.zong_ge
	if v == nil {
		return
	}
	return *v, true
}

// OldZongGe returns the old "zong_ge" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongGe(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongGe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongGe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongGe: %w", err)
	}
	return oldValue.ZongGe, nil
}

// AddZongGe adds i to the "zong_ge" field.
func (m *WuGeLuckyMutation) AddZongGe(i int32) {
	if m.addzong_ge != nil {
		*m.addzong_ge += i
	} else {
		m.addzong_ge = &i
	}
}

// AddedZongGe returns the value that was added to the "zong_ge" field in this mutation.
func (m *WuGeLuckyMutation) AddedZongGe() (r int32, exists bool) {
	v := m.addzong_ge
	if v == nil {
		return
	}
	return *v, true
}

// ClearZongGe clears the value of the "zong_ge" field.
func (m *WuGeLuckyMutation) ClearZongGe() {
	m.zong_ge = nil
	m.addzong_ge = nil
	m.clearedFields[wugelucky.FieldZongGe] = struct{}{}
}

// ZongGeCleared returns if the "zong_ge" field was cleared in this mutation.
func (m *WuGeLuckyMutation) ZongGeCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldZongGe]
	return ok
}

// ResetZongGe resets all changes to the "zong_ge" field.
func (m *WuGeLuckyMutation) ResetZongGe() {
	m.zong_ge = nil
	m.addzong_ge = nil
	delete(m.clearedFields, wugelucky.FieldZongGe)
}

// SetZongDaYan sets the "zong_da_yan" field.
func (m *WuGeLuckyMutation) SetZongDaYan(s string) {
	m.zong_da_yan = &s
}

// ZongDaYan returns the value of the "zong_da_yan" field in the mutation.
func (m *WuGeLuckyMutation) ZongDaYan() (r string, exists bool) {
	v := m.zong_da_yan
	if v == nil {
		return
	}
	return *v, true
}

// OldZongDaYan returns the old "zong_da_yan" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongDaYan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongDaYan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongDaYan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongDaYan: %w", err)
	}
	return oldValue.ZongDaYan, nil
}

// ClearZongDaYan clears the value of the "zong_da_yan" field.
func (m *WuGeLuckyMutation) ClearZongDaYan() {
	m.zong_da_yan = nil
	m.clearedFields[wugelucky.FieldZongDaYan] = struct{}{}
}

// ZongDaYanCleared returns if the "zong_da_yan" field was cleared in this mutation.
func (m *WuGeLuckyMutation) ZongDaYanCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldZongDaYan]
	return ok
}

// ResetZongDaYan resets all changes to the "zong_da_yan" field.
func (m *WuGeLuckyMutation) ResetZongDaYan() {
	m.zong_da_yan = nil
	delete(m.clearedFields, wugelucky.FieldZongDaYan)
}

// SetZongLucky sets the "zong_lucky" field.
func (m *WuGeLuckyMutation) SetZongLucky(b bool) {
	m.zong_lucky = &b
}

// ZongLucky returns the value of the "zong_lucky" field in the mutation.
func (m *WuGeLuckyMutation) ZongLucky() (r bool, exists bool) {
	v := m.zong_lucky
	if v == nil {
		return
	}
	return *v, true
}

// OldZongLucky returns the old "zong_lucky" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongLucky(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongLucky is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongLucky requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongLucky: %w", err)
	}
	return oldValue.ZongLucky, nil
}

// ClearZongLucky clears the value of the "zong_lucky" field.
func (m *WuGeLuckyMutation) ClearZongLucky() {
	m.zong_lucky = nil
	m.clearedFields[wugelucky.FieldZongLucky] = struct{}{}
}

// ZongLuckyCleared returns if the "zong_lucky" field was cleared in this mutation.
func (m *WuGeLuckyMutation) ZongLuckyCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldZongLucky]
	return ok
}

// ResetZongLucky resets all changes to the "zong_lucky" field.
func (m *WuGeLuckyMutation) ResetZongLucky() {
	m.zong_lucky = nil
	delete(m.clearedFields, wugelucky.FieldZongLucky)
}

// SetZongSex sets the "zong_sex" field.
func (m *WuGeLuckyMutation) SetZongSex(b bool) {
	m.zong_sex = &b
}

// ZongSex returns the value of the "zong_sex" field in the mutation.
func (m *WuGeLuckyMutation) ZongSex() (r bool, exists bool) {
	v := m.zong_sex
	if v == nil {
		return
	}
	return *v, true
}

// OldZongSex returns the old "zong_sex" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongSex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongSex: %w", err)
	}
	return oldValue.ZongSex, nil
}

// ClearZongSex clears the value of the "zong_sex" field.
func (m *WuGeLuckyMutation) ClearZongSex() {
	m.zong_sex = nil
	m.clearedFields[wugelucky.FieldZongSex] = struct{}{}
}

// ZongSexCleared returns if the "zong_sex" field was cleared in this mutation.
func (m *WuGeLuckyMutation) ZongSexCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldZongSex]
	return ok
}

// ResetZongSex resets all changes to the "zong_sex" field.
func (m *WuGeLuckyMutation) ResetZongSex() {
	m.zong_sex = nil
	delete(m.clearedFields, wugelucky.FieldZongSex)
}

// SetZongMax sets the "zong_max" field.
func (m *WuGeLuckyMutation) SetZongMax(b bool) {
	m.zong_max = &b
}

// ZongMax returns the value of the "zong_max" field in the mutation.
func (m *WuGeLuckyMutation) ZongMax() (r bool, exists bool) {
	v := m.zong_max
	if v == nil {
		return
	}
	return *v, true
}

// OldZongMax returns the old "zong_max" field's value of the WuGeLucky entity.
// If the WuGeLucky object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuGeLuckyMutation) OldZongMax(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZongMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZongMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZongMax: %w", err)
	}
	return oldValue.ZongMax, nil
}

// ClearZongMax clears the value of the "zong_max" field.
func (m *WuGeLuckyMutation) ClearZongMax() {
	m.zong_max = nil
	m.clearedFields[wugelucky.FieldZongMax] = struct{}{}
}

// ZongMaxCleared returns if the "zong_max" field was cleared in this mutation.
func (m *WuGeLuckyMutation) ZongMaxCleared() bool {
	_, ok := m.clearedFields[wugelucky.FieldZongMax]
	return ok
}

// ResetZongMax resets all changes to the "zong_max" field.
func (m *WuGeLuckyMutation) ResetZongMax() {
	m.zong_max = nil
	delete(m.clearedFields, wugelucky.FieldZongMax)
}

// Where appends a list predicates to the WuGeLuckyMutation builder.
func (m *WuGeLuckyMutation) Where(ps ...predicate.WuGeLucky) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WuGeLuckyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WuGeLucky).
func (m *WuGeLuckyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WuGeLuckyMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.last_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldLastStroke1)
	}
	if m.last_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldLastStroke2)
	}
	if m.first_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke1)
	}
	if m.first_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke2)
	}
	if m.tian_ge != nil {
		fields = append(fields, wugelucky.FieldTianGe)
	}
	if m.tian_da_yan != nil {
		fields = append(fields, wugelucky.FieldTianDaYan)
	}
	if m.ren_ge != nil {
		fields = append(fields, wugelucky.FieldRenGe)
	}
	if m.ren_da_yan != nil {
		fields = append(fields, wugelucky.FieldRenDaYan)
	}
	if m.di_ge != nil {
		fields = append(fields, wugelucky.FieldDiGe)
	}
	if m.di_da_yan != nil {
		fields = append(fields, wugelucky.FieldDiDaYan)
	}
	if m.wai_ge != nil {
		fields = append(fields, wugelucky.FieldWaiGe)
	}
	if m.wai_da_yan != nil {
		fields = append(fields, wugelucky.FieldWaiDaYan)
	}
	if m.zong_ge != nil {
		fields = append(fields, wugelucky.FieldZongGe)
	}
	if m.zong_da_yan != nil {
		fields = append(fields, wugelucky.FieldZongDaYan)
	}
	if m.zong_lucky != nil {
		fields = append(fields, wugelucky.FieldZongLucky)
	}
	if m.zong_sex != nil {
		fields = append(fields, wugelucky.FieldZongSex)
	}
	if m.zong_max != nil {
		fields = append(fields, wugelucky.FieldZongMax)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WuGeLuckyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.LastStroke1()
	case wugelucky.FieldLastStroke2:
		return m.LastStroke2()
	case wugelucky.FieldFirstStroke1:
		return m.FirstStroke1()
	case wugelucky.FieldFirstStroke2:
		return m.FirstStroke2()
	case wugelucky.FieldTianGe:
		return m.TianGe()
	case wugelucky.FieldTianDaYan:
		return m.TianDaYan()
	case wugelucky.FieldRenGe:
		return m.RenGe()
	case wugelucky.FieldRenDaYan:
		return m.RenDaYan()
	case wugelucky.FieldDiGe:
		return m.DiGe()
	case wugelucky.FieldDiDaYan:
		return m.DiDaYan()
	case wugelucky.FieldWaiGe:
		return m.WaiGe()
	case wugelucky.FieldWaiDaYan:
		return m.WaiDaYan()
	case wugelucky.FieldZongGe:
		return m.ZongGe()
	case wugelucky.FieldZongDaYan:
		return m.ZongDaYan()
	case wugelucky.FieldZongLucky:
		return m.ZongLucky()
	case wugelucky.FieldZongSex:
		return m.ZongSex()
	case wugelucky.FieldZongMax:
		return m.ZongMax()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WuGeLuckyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.OldLastStroke1(ctx)
	case wugelucky.FieldLastStroke2:
		return m.OldLastStroke2(ctx)
	case wugelucky.FieldFirstStroke1:
		return m.OldFirstStroke1(ctx)
	case wugelucky.FieldFirstStroke2:
		return m.OldFirstStroke2(ctx)
	case wugelucky.FieldTianGe:
		return m.OldTianGe(ctx)
	case wugelucky.FieldTianDaYan:
		return m.OldTianDaYan(ctx)
	case wugelucky.FieldRenGe:
		return m.OldRenGe(ctx)
	case wugelucky.FieldRenDaYan:
		return m.OldRenDaYan(ctx)
	case wugelucky.FieldDiGe:
		return m.OldDiGe(ctx)
	case wugelucky.FieldDiDaYan:
		return m.OldDiDaYan(ctx)
	case wugelucky.FieldWaiGe:
		return m.OldWaiGe(ctx)
	case wugelucky.FieldWaiDaYan:
		return m.OldWaiDaYan(ctx)
	case wugelucky.FieldZongGe:
		return m.OldZongGe(ctx)
	case wugelucky.FieldZongDaYan:
		return m.OldZongDaYan(ctx)
	case wugelucky.FieldZongLucky:
		return m.OldZongLucky(ctx)
	case wugelucky.FieldZongSex:
		return m.OldZongSex(ctx)
	case wugelucky.FieldZongMax:
		return m.OldZongMax(ctx)
	}
	return nil, fmt.Errorf("unknown WuGeLucky field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuGeLuckyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStroke1(v)
		return nil
	case wugelucky.FieldLastStroke2:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStroke2(v)
		return nil
	case wugelucky.FieldFirstStroke1:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStroke1(v)
		return nil
	case wugelucky.FieldFirstStroke2:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstStroke2(v)
		return nil
	case wugelucky.FieldTianGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTianGe(v)
		return nil
	case wugelucky.FieldTianDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTianDaYan(v)
		return nil
	case wugelucky.FieldRenGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenGe(v)
		return nil
	case wugelucky.FieldRenDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenDaYan(v)
		return nil
	case wugelucky.FieldDiGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiGe(v)
		return nil
	case wugelucky.FieldDiDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiDaYan(v)
		return nil
	case wugelucky.FieldWaiGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiGe(v)
		return nil
	case wugelucky.FieldWaiDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiDaYan(v)
		return nil
	case wugelucky.FieldZongGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongGe(v)
		return nil
	case wugelucky.FieldZongDaYan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongDaYan(v)
		return nil
	case wugelucky.FieldZongLucky:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongLucky(v)
		return nil
	case wugelucky.FieldZongSex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongSex(v)
		return nil
	case wugelucky.FieldZongMax:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZongMax(v)
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WuGeLuckyMutation) AddedFields() []string {
	var fields []string
	if m.addlast_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldLastStroke1)
	}
	if m.addlast_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldLastStroke2)
	}
	if m.addfirst_stroke_1 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke1)
	}
	if m.addfirst_stroke_2 != nil {
		fields = append(fields, wugelucky.FieldFirstStroke2)
	}
	if m.addtian_ge != nil {
		fields = append(fields, wugelucky.FieldTianGe)
	}
	if m.addren_ge != nil {
		fields = append(fields, wugelucky.FieldRenGe)
	}
	if m.adddi_ge != nil {
		fields = append(fields, wugelucky.FieldDiGe)
	}
	if m.addwai_ge != nil {
		fields = append(fields, wugelucky.FieldWaiGe)
	}
	if m.addzong_ge != nil {
		fields = append(fields, wugelucky.FieldZongGe)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WuGeLuckyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wugelucky.FieldLastStroke1:
		return m.AddedLastStroke1()
	case wugelucky.FieldLastStroke2:
		return m.AddedLastStroke2()
	case wugelucky.FieldFirstStroke1:
		return m.AddedFirstStroke1()
	case wugelucky.FieldFirstStroke2:
		return m.AddedFirstStroke2()
	case wugelucky.FieldTianGe:
		return m.AddedTianGe()
	case wugelucky.FieldRenGe:
		return m.AddedRenGe()
	case wugelucky.FieldDiGe:
		return m.AddedDiGe()
	case wugelucky.FieldWaiGe:
		return m.AddedWaiGe()
	case wugelucky.FieldZongGe:
		return m.AddedZongGe()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuGeLuckyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastStroke1(v)
		return nil
	case wugelucky.FieldLastStroke2:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastStroke2(v)
		return nil
	case wugelucky.FieldFirstStroke1:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstStroke1(v)
		return nil
	case wugelucky.FieldFirstStroke2:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstStroke2(v)
		return nil
	case wugelucky.FieldTianGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTianGe(v)
		return nil
	case wugelucky.FieldRenGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenGe(v)
		return nil
	case wugelucky.FieldDiGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiGe(v)
		return nil
	case wugelucky.FieldWaiGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWaiGe(v)
		return nil
	case wugelucky.FieldZongGe:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZongGe(v)
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WuGeLuckyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wugelucky.FieldLastStroke1) {
		fields = append(fields, wugelucky.FieldLastStroke1)
	}
	if m.FieldCleared(wugelucky.FieldLastStroke2) {
		fields = append(fields, wugelucky.FieldLastStroke2)
	}
	if m.FieldCleared(wugelucky.FieldFirstStroke1) {
		fields = append(fields, wugelucky.FieldFirstStroke1)
	}
	if m.FieldCleared(wugelucky.FieldFirstStroke2) {
		fields = append(fields, wugelucky.FieldFirstStroke2)
	}
	if m.FieldCleared(wugelucky.FieldTianGe) {
		fields = append(fields, wugelucky.FieldTianGe)
	}
	if m.FieldCleared(wugelucky.FieldTianDaYan) {
		fields = append(fields, wugelucky.FieldTianDaYan)
	}
	if m.FieldCleared(wugelucky.FieldRenGe) {
		fields = append(fields, wugelucky.FieldRenGe)
	}
	if m.FieldCleared(wugelucky.FieldRenDaYan) {
		fields = append(fields, wugelucky.FieldRenDaYan)
	}
	if m.FieldCleared(wugelucky.FieldDiGe) {
		fields = append(fields, wugelucky.FieldDiGe)
	}
	if m.FieldCleared(wugelucky.FieldDiDaYan) {
		fields = append(fields, wugelucky.FieldDiDaYan)
	}
	if m.FieldCleared(wugelucky.FieldWaiGe) {
		fields = append(fields, wugelucky.FieldWaiGe)
	}
	if m.FieldCleared(wugelucky.FieldWaiDaYan) {
		fields = append(fields, wugelucky.FieldWaiDaYan)
	}
	if m.FieldCleared(wugelucky.FieldZongGe) {
		fields = append(fields, wugelucky.FieldZongGe)
	}
	if m.FieldCleared(wugelucky.FieldZongDaYan) {
		fields = append(fields, wugelucky.FieldZongDaYan)
	}
	if m.FieldCleared(wugelucky.FieldZongLucky) {
		fields = append(fields, wugelucky.FieldZongLucky)
	}
	if m.FieldCleared(wugelucky.FieldZongSex) {
		fields = append(fields, wugelucky.FieldZongSex)
	}
	if m.FieldCleared(wugelucky.FieldZongMax) {
		fields = append(fields, wugelucky.FieldZongMax)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WuGeLuckyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WuGeLuckyMutation) ClearField(name string) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		m.ClearLastStroke1()
		return nil
	case wugelucky.FieldLastStroke2:
		m.ClearLastStroke2()
		return nil
	case wugelucky.FieldFirstStroke1:
		m.ClearFirstStroke1()
		return nil
	case wugelucky.FieldFirstStroke2:
		m.ClearFirstStroke2()
		return nil
	case wugelucky.FieldTianGe:
		m.ClearTianGe()
		return nil
	case wugelucky.FieldTianDaYan:
		m.ClearTianDaYan()
		return nil
	case wugelucky.FieldRenGe:
		m.ClearRenGe()
		return nil
	case wugelucky.FieldRenDaYan:
		m.ClearRenDaYan()
		return nil
	case wugelucky.FieldDiGe:
		m.ClearDiGe()
		return nil
	case wugelucky.FieldDiDaYan:
		m.ClearDiDaYan()
		return nil
	case wugelucky.FieldWaiGe:
		m.ClearWaiGe()
		return nil
	case wugelucky.FieldWaiDaYan:
		m.ClearWaiDaYan()
		return nil
	case wugelucky.FieldZongGe:
		m.ClearZongGe()
		return nil
	case wugelucky.FieldZongDaYan:
		m.ClearZongDaYan()
		return nil
	case wugelucky.FieldZongLucky:
		m.ClearZongLucky()
		return nil
	case wugelucky.FieldZongSex:
		m.ClearZongSex()
		return nil
	case wugelucky.FieldZongMax:
		m.ClearZongMax()
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WuGeLuckyMutation) ResetField(name string) error {
	switch name {
	case wugelucky.FieldLastStroke1:
		m.ResetLastStroke1()
		return nil
	case wugelucky.FieldLastStroke2:
		m.ResetLastStroke2()
		return nil
	case wugelucky.FieldFirstStroke1:
		m.ResetFirstStroke1()
		return nil
	case wugelucky.FieldFirstStroke2:
		m.ResetFirstStroke2()
		return nil
	case wugelucky.FieldTianGe:
		m.ResetTianGe()
		return nil
	case wugelucky.FieldTianDaYan:
		m.ResetTianDaYan()
		return nil
	case wugelucky.FieldRenGe:
		m.ResetRenGe()
		return nil
	case wugelucky.FieldRenDaYan:
		m.ResetRenDaYan()
		return nil
	case wugelucky.FieldDiGe:
		m.ResetDiGe()
		return nil
	case wugelucky.FieldDiDaYan:
		m.ResetDiDaYan()
		return nil
	case wugelucky.FieldWaiGe:
		m.ResetWaiGe()
		return nil
	case wugelucky.FieldWaiDaYan:
		m.ResetWaiDaYan()
		return nil
	case wugelucky.FieldZongGe:
		m.ResetZongGe()
		return nil
	case wugelucky.FieldZongDaYan:
		m.ResetZongDaYan()
		return nil
	case wugelucky.FieldZongLucky:
		m.ResetZongLucky()
		return nil
	case wugelucky.FieldZongSex:
		m.ResetZongSex()
		return nil
	case wugelucky.FieldZongMax:
		m.ResetZongMax()
		return nil
	}
	return fmt.Errorf("unknown WuGeLucky field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WuGeLuckyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WuGeLuckyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WuGeLuckyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WuGeLuckyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WuGeLuckyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WuGeLuckyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WuGeLuckyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WuGeLucky unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WuGeLuckyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WuGeLucky edge %s", name)
}

// WuXingMutation represents an operation that mutates the WuXing nodes in the graph.
type WuXingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created       *time.Time
	updated       *time.Time
	deleted       *time.Time
	version       *int32
	addversion    *int32
	first         *string
	second        *string
	third         *string
	fortune       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WuXing, error)
	predicates    []predicate.WuXing
}

var _ ent.Mutation = (*WuXingMutation)(nil)

// wuxingOption allows management of the mutation configuration using functional options.
type wuxingOption func(*WuXingMutation)

// newWuXingMutation creates new mutation for the WuXing entity.
func newWuXingMutation(c config, op Op, opts ...wuxingOption) *WuXingMutation {
	m := &WuXingMutation{
		config:        c,
		op:            op,
		typ:           TypeWuXing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWuXingID sets the ID field of the mutation.
func withWuXingID(id string) wuxingOption {
	return func(m *WuXingMutation) {
		var (
			err   error
			once  sync.Once
			value *WuXing
		)
		m.oldValue = func(ctx context.Context) (*WuXing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WuXing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWuXing sets the old WuXing of the mutation.
func withWuXing(node *WuXing) wuxingOption {
	return func(m *WuXingMutation) {
		m.oldValue = func(context.Context) (*WuXing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WuXingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WuXingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WuXing entities.
func (m *WuXingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WuXingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WuXingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WuXing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreated sets the "created" field.
func (m *WuXingMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *WuXingMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *WuXingMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[wuxing.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *WuXingMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *WuXingMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, wuxing.FieldCreated)
}

// SetUpdated sets the "updated" field.
func (m *WuXingMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *WuXingMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *WuXingMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[wuxing.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *WuXingMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *WuXingMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, wuxing.FieldUpdated)
}

// SetDeleted sets the "deleted" field.
func (m *WuXingMutation) SetDeleted(t time.Time) {
	m.deleted = &t
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *WuXingMutation) Deleted() (r time.Time, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldDeleted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ClearDeleted clears the value of the "deleted" field.
func (m *WuXingMutation) ClearDeleted() {
	m.deleted = nil
	m.clearedFields[wuxing.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the "deleted" field was cleared in this mutation.
func (m *WuXingMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldDeleted]
	return ok
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *WuXingMutation) ResetDeleted() {
	m.deleted = nil
	delete(m.clearedFields, wuxing.FieldDeleted)
}

// SetVersion sets the "version" field.
func (m *WuXingMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WuXingMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WuXingMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WuXingMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *WuXingMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[wuxing.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *WuXingMutation) VersionCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *WuXingMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, wuxing.FieldVersion)
}

// SetFirst sets the "first" field.
func (m *WuXingMutation) SetFirst(s string) {
	m.first = &s
}

// First returns the value of the "first" field in the mutation.
func (m *WuXingMutation) First() (r string, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldFirst(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ClearFirst clears the value of the "first" field.
func (m *WuXingMutation) ClearFirst() {
	m.first = nil
	m.clearedFields[wuxing.FieldFirst] = struct{}{}
}

// FirstCleared returns if the "first" field was cleared in this mutation.
func (m *WuXingMutation) FirstCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldFirst]
	return ok
}

// ResetFirst resets all changes to the "first" field.
func (m *WuXingMutation) ResetFirst() {
	m.first = nil
	delete(m.clearedFields, wuxing.FieldFirst)
}

// SetSecond sets the "second" field.
func (m *WuXingMutation) SetSecond(s string) {
	m.second = &s
}

// Second returns the value of the "second" field in the mutation.
func (m *WuXingMutation) Second() (r string, exists bool) {
	v := m.second
	if v == nil {
		return
	}
	return *v, true
}

// OldSecond returns the old "second" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldSecond(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecond: %w", err)
	}
	return oldValue.Second, nil
}

// ClearSecond clears the value of the "second" field.
func (m *WuXingMutation) ClearSecond() {
	m.second = nil
	m.clearedFields[wuxing.FieldSecond] = struct{}{}
}

// SecondCleared returns if the "second" field was cleared in this mutation.
func (m *WuXingMutation) SecondCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldSecond]
	return ok
}

// ResetSecond resets all changes to the "second" field.
func (m *WuXingMutation) ResetSecond() {
	m.second = nil
	delete(m.clearedFields, wuxing.FieldSecond)
}

// SetThird sets the "third" field.
func (m *WuXingMutation) SetThird(s string) {
	m.third = &s
}

// Third returns the value of the "third" field in the mutation.
func (m *WuXingMutation) Third() (r string, exists bool) {
	v := m.third
	if v == nil {
		return
	}
	return *v, true
}

// OldThird returns the old "third" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldThird(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThird is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThird requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThird: %w", err)
	}
	return oldValue.Third, nil
}

// ClearThird clears the value of the "third" field.
func (m *WuXingMutation) ClearThird() {
	m.third = nil
	m.clearedFields[wuxing.FieldThird] = struct{}{}
}

// ThirdCleared returns if the "third" field was cleared in this mutation.
func (m *WuXingMutation) ThirdCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldThird]
	return ok
}

// ResetThird resets all changes to the "third" field.
func (m *WuXingMutation) ResetThird() {
	m.third = nil
	delete(m.clearedFields, wuxing.FieldThird)
}

// SetFortune sets the "fortune" field.
func (m *WuXingMutation) SetFortune(s string) {
	m.fortune = &s
}

// Fortune returns the value of the "fortune" field in the mutation.
func (m *WuXingMutation) Fortune() (r string, exists bool) {
	v := m.fortune
	if v == nil {
		return
	}
	return *v, true
}

// OldFortune returns the old "fortune" field's value of the WuXing entity.
// If the WuXing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WuXingMutation) OldFortune(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFortune is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFortune requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFortune: %w", err)
	}
	return oldValue.Fortune, nil
}

// ClearFortune clears the value of the "fortune" field.
func (m *WuXingMutation) ClearFortune() {
	m.fortune = nil
	m.clearedFields[wuxing.FieldFortune] = struct{}{}
}

// FortuneCleared returns if the "fortune" field was cleared in this mutation.
func (m *WuXingMutation) FortuneCleared() bool {
	_, ok := m.clearedFields[wuxing.FieldFortune]
	return ok
}

// ResetFortune resets all changes to the "fortune" field.
func (m *WuXingMutation) ResetFortune() {
	m.fortune = nil
	delete(m.clearedFields, wuxing.FieldFortune)
}

// Where appends a list predicates to the WuXingMutation builder.
func (m *WuXingMutation) Where(ps ...predicate.WuXing) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WuXingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WuXing).
func (m *WuXingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WuXingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created != nil {
		fields = append(fields, wuxing.FieldCreated)
	}
	if m.updated != nil {
		fields = append(fields, wuxing.FieldUpdated)
	}
	if m.deleted != nil {
		fields = append(fields, wuxing.FieldDeleted)
	}
	if m.version != nil {
		fields = append(fields, wuxing.FieldVersion)
	}
	if m.first != nil {
		fields = append(fields, wuxing.FieldFirst)
	}
	if m.second != nil {
		fields = append(fields, wuxing.FieldSecond)
	}
	if m.third != nil {
		fields = append(fields, wuxing.FieldThird)
	}
	if m.fortune != nil {
		fields = append(fields, wuxing.FieldFortune)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WuXingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wuxing.FieldCreated:
		return m.Created()
	case wuxing.FieldUpdated:
		return m.Updated()
	case wuxing.FieldDeleted:
		return m.Deleted()
	case wuxing.FieldVersion:
		return m.Version()
	case wuxing.FieldFirst:
		return m.First()
	case wuxing.FieldSecond:
		return m.Second()
	case wuxing.FieldThird:
		return m.Third()
	case wuxing.FieldFortune:
		return m.Fortune()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WuXingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wuxing.FieldCreated:
		return m.OldCreated(ctx)
	case wuxing.FieldUpdated:
		return m.OldUpdated(ctx)
	case wuxing.FieldDeleted:
		return m.OldDeleted(ctx)
	case wuxing.FieldVersion:
		return m.OldVersion(ctx)
	case wuxing.FieldFirst:
		return m.OldFirst(ctx)
	case wuxing.FieldSecond:
		return m.OldSecond(ctx)
	case wuxing.FieldThird:
		return m.OldThird(ctx)
	case wuxing.FieldFortune:
		return m.OldFortune(ctx)
	}
	return nil, fmt.Errorf("unknown WuXing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuXingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wuxing.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case wuxing.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case wuxing.FieldDeleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case wuxing.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case wuxing.FieldFirst:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case wuxing.FieldSecond:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecond(v)
		return nil
	case wuxing.FieldThird:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThird(v)
		return nil
	case wuxing.FieldFortune:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFortune(v)
		return nil
	}
	return fmt.Errorf("unknown WuXing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WuXingMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, wuxing.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WuXingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wuxing.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WuXingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wuxing.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown WuXing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WuXingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wuxing.FieldCreated) {
		fields = append(fields, wuxing.FieldCreated)
	}
	if m.FieldCleared(wuxing.FieldUpdated) {
		fields = append(fields, wuxing.FieldUpdated)
	}
	if m.FieldCleared(wuxing.FieldDeleted) {
		fields = append(fields, wuxing.FieldDeleted)
	}
	if m.FieldCleared(wuxing.FieldVersion) {
		fields = append(fields, wuxing.FieldVersion)
	}
	if m.FieldCleared(wuxing.FieldFirst) {
		fields = append(fields, wuxing.FieldFirst)
	}
	if m.FieldCleared(wuxing.FieldSecond) {
		fields = append(fields, wuxing.FieldSecond)
	}
	if m.FieldCleared(wuxing.FieldThird) {
		fields = append(fields, wuxing.FieldThird)
	}
	if m.FieldCleared(wuxing.FieldFortune) {
		fields = append(fields, wuxing.FieldFortune)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WuXingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WuXingMutation) ClearField(name string) error {
	switch name {
	case wuxing.FieldCreated:
		m.ClearCreated()
		return nil
	case wuxing.FieldUpdated:
		m.ClearUpdated()
		return nil
	case wuxing.FieldDeleted:
		m.ClearDeleted()
		return nil
	case wuxing.FieldVersion:
		m.ClearVersion()
		return nil
	case wuxing.FieldFirst:
		m.ClearFirst()
		return nil
	case wuxing.FieldSecond:
		m.ClearSecond()
		return nil
	case wuxing.FieldThird:
		m.ClearThird()
		return nil
	case wuxing.FieldFortune:
		m.ClearFortune()
		return nil
	}
	return fmt.Errorf("unknown WuXing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WuXingMutation) ResetField(name string) error {
	switch name {
	case wuxing.FieldCreated:
		m.ResetCreated()
		return nil
	case wuxing.FieldUpdated:
		m.ResetUpdated()
		return nil
	case wuxing.FieldDeleted:
		m.ResetDeleted()
		return nil
	case wuxing.FieldVersion:
		m.ResetVersion()
		return nil
	case wuxing.FieldFirst:
		m.ResetFirst()
		return nil
	case wuxing.FieldSecond:
		m.ResetSecond()
		return nil
	case wuxing.FieldThird:
		m.ResetThird()
		return nil
	case wuxing.FieldFortune:
		m.ResetFortune()
		return nil
	}
	return fmt.Errorf("unknown WuXing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WuXingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WuXingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WuXingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WuXingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WuXingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WuXingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WuXingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WuXing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WuXingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WuXing edge %s", name)
}
